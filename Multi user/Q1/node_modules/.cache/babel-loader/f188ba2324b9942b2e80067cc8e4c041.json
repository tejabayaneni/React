{"ast":null,"code":"\"use strict\";\n\nfunction Renderer() {}\n/**\n *  Walks the AST and calls member methods for each Node type.\n *\n *  @param ast {Node} The root of the abstract syntax tree.\n */\n\n\nfunction render(ast) {\n  var walker = ast.walker(),\n      event,\n      type;\n  this.buffer = '';\n  this.lastOut = '\\n';\n\n  while (event = walker.next()) {\n    type = event.node.type;\n\n    if (this[type]) {\n      this[type](event.node, event.entering);\n    }\n  }\n\n  return this.buffer;\n}\n/**\n *  Concatenate a literal string to the buffer.\n *\n *  @param str {String} The string to concatenate.\n */\n\n\nfunction lit(str) {\n  this.buffer += str;\n  this.lastOut = str;\n}\n/**\n *  Output a newline to the buffer.\n */\n\n\nfunction cr() {\n  if (this.lastOut !== '\\n') {\n    this.lit('\\n');\n  }\n}\n/**\n *  Concatenate a string to the buffer possibly escaping the content.\n *\n *  Concrete renderer implementations should override this method.\n *\n *  @param str {String} The string to concatenate.\n */\n\n\nfunction out(str) {\n  this.lit(str);\n}\n/**\n *  Escape a string for the target renderer.\n *\n *  Abstract function that should be implemented by concrete \n *  renderer implementations.\n *\n *  @param str {String} The string to escape.\n */\n\n\nfunction esc(str) {\n  return str;\n}\n\nRenderer.prototype.render = render;\nRenderer.prototype.out = out;\nRenderer.prototype.lit = lit;\nRenderer.prototype.cr = cr;\nRenderer.prototype.esc = esc;\nmodule.exports = Renderer;","map":null,"metadata":{},"sourceType":"script"}