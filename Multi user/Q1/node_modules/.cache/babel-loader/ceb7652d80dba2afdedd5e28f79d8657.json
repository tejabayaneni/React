{"ast":null,"code":"\"use strict\";\n\nvar Node = require('./node');\n\nvar unescapeString = require('./common').unescapeString;\n\nvar OPENTAG = require('./common').OPENTAG;\n\nvar CLOSETAG = require('./common').CLOSETAG;\n\nvar CODE_INDENT = 4;\nvar C_TAB = 9;\nvar C_NEWLINE = 10;\nvar C_GREATERTHAN = 62;\nvar C_LESSTHAN = 60;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\n\nvar InlineParser = require('./inlines');\n\nvar reHtmlBlockOpen = [/./, // dummy for 0\n/^<(?:script|pre|style)(?:\\s|>|$)/i, /^<!--/, /^<[?]/, /^<![A-Z]/, /^<!\\[CDATA\\[/, /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|title|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|[/]?[>]|$)/i, new RegExp('^(?:' + OPENTAG + '|' + CLOSETAG + ')\\\\s*$', 'i')];\nvar reHtmlBlockClose = [/./, // dummy for 0\n/<\\/(?:script|pre|style)>/i, /-->/, /\\?>/, />/, /\\]\\]>/];\nvar reThematicBreak = /^(?:(?:\\*[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:-[ \\t]*){3,})[ \\t]*$/;\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-]/;\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\nvar reBulletListMarker = /^[*+-]/;\nvar reOrderedListMarker = /^(\\d{1,9})([.)])/;\nvar reATXHeadingMarker = /^#{1,6}(?:[ \\t]+|$)/;\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}(?!.*~)/;\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\nvar reSetextHeadingLine = /^(?:=+|-+)[ \\t]*$/;\nvar reLineEnding = /\\r\\n|\\n|\\r/; // Returns true if string contains only space characters.\n\nvar isBlank = function isBlank(s) {\n  return !reNonSpace.test(s);\n};\n\nvar isSpaceOrTab = function isSpaceOrTab(c) {\n  return c === C_SPACE || c === C_TAB;\n};\n\nvar peek = function peek(ln, pos) {\n  if (pos < ln.length) {\n    return ln.charCodeAt(pos);\n  } else {\n    return -1;\n  }\n}; // DOC PARSER\n// These are methods of a Parser object, defined below.\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\n\n\nvar endsWithBlankLine = function endsWithBlankLine(block) {\n  while (block) {\n    if (block._lastLineBlank) {\n      return true;\n    }\n\n    var t = block.type;\n\n    if (t === 'list' || t === 'item') {\n      block = block._lastChild;\n    } else {\n      break;\n    }\n  }\n\n  return false;\n}; // Add a line to the block at the tip.  We assume the tip\n// can accept lines -- that check should be done before calling this.\n\n\nvar addLine = function addLine() {\n  if (this.partiallyConsumedTab) {\n    this.offset += 1; // skip over tab\n    // add space characters:\n\n    var charsToTab = 4 - this.column % 4;\n    this.tip._string_content += ' '.repeat(charsToTab);\n  }\n\n  this.tip._string_content += this.currentLine.slice(this.offset) + '\\n';\n}; // Add block of type tag as a child of the tip.  If the tip can't\n// accept children, close and finalize it and try its parent,\n// and so on til we find a block that can accept children.\n\n\nvar addChild = function addChild(tag, offset) {\n  while (!this.blocks[this.tip.type].canContain(tag)) {\n    this.finalize(this.tip, this.lineNumber - 1);\n  }\n\n  var column_number = offset + 1; // offset 0 = column 1\n\n  var newBlock = new Node(tag, [[this.lineNumber, column_number], [0, 0]]);\n  newBlock._string_content = '';\n  this.tip.appendChild(newBlock);\n  this.tip = newBlock;\n  return newBlock;\n}; // Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\n\n\nvar parseListMarker = function parseListMarker(parser, container) {\n  var rest = parser.currentLine.slice(parser.nextNonspace);\n  var match;\n  var nextc;\n  var spacesStartCol;\n  var spacesStartOffset;\n  var data = {\n    type: null,\n    tight: true,\n    // lists are tight by default\n    bulletChar: null,\n    start: null,\n    delimiter: null,\n    padding: null,\n    markerOffset: parser.indent\n  };\n\n  if (match = rest.match(reBulletListMarker)) {\n    data.type = 'bullet';\n    data.bulletChar = match[0][0];\n  } else if ((match = rest.match(reOrderedListMarker)) && (container.type !== 'paragraph' || match[1] === '1')) {\n    data.type = 'ordered';\n    data.start = parseInt(match[1]);\n    data.delimiter = match[2];\n  } else {\n    return null;\n  } // make sure we have spaces after\n\n\n  nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);\n\n  if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {\n    return null;\n  } // if it interrupts paragraph, make sure first line isn't blank\n\n\n  if (container.type === 'paragraph' && !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {\n    return null;\n  } // we've got a match! advance offset and calculate padding\n\n\n  parser.advanceNextNonspace(); // to start of marker\n\n  parser.advanceOffset(match[0].length, true); // to end of marker\n\n  spacesStartCol = parser.column;\n  spacesStartOffset = parser.offset;\n\n  do {\n    parser.advanceOffset(1, true);\n    nextc = peek(parser.currentLine, parser.offset);\n  } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));\n\n  var blank_item = peek(parser.currentLine, parser.offset) === -1;\n  var spaces_after_marker = parser.column - spacesStartCol;\n\n  if (spaces_after_marker >= 5 || spaces_after_marker < 1 || blank_item) {\n    data.padding = match[0].length + 1;\n    parser.column = spacesStartCol;\n    parser.offset = spacesStartOffset;\n\n    if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n      parser.advanceOffset(1, true);\n    }\n  } else {\n    data.padding = match[0].length + spaces_after_marker;\n  }\n\n  return data;\n}; // Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\n\n\nvar listsMatch = function listsMatch(list_data, item_data) {\n  return list_data.type === item_data.type && list_data.delimiter === item_data.delimiter && list_data.bulletChar === item_data.bulletChar;\n}; // Finalize and close any unmatched blocks.\n\n\nvar closeUnmatchedBlocks = function closeUnmatchedBlocks() {\n  if (!this.allClosed) {\n    // finalize any blocks not matched\n    while (this.oldtip !== this.lastMatchedContainer) {\n      var parent = this.oldtip._parent;\n      this.finalize(this.oldtip, this.lineNumber - 1);\n      this.oldtip = parent;\n    }\n\n    this.allClosed = true;\n  }\n}; // 'finalize' is run when the block is closed.\n// 'continue' is run to check whether the block is continuing\n// at a certain line and offset (e.g. whether a block quote\n// contains a `>`.  It returns 0 for matched, 1 for not matched,\n// and 2 for \"we've dealt with this line completely, go to next.\"\n\n\nvar blocks = {\n  document: {\n    continue: function _continue() {\n      return 0;\n    },\n    finalize: function finalize() {\n      return;\n    },\n    canContain: function canContain(t) {\n      return t !== 'item';\n    },\n    acceptsLines: false\n  },\n  list: {\n    continue: function _continue() {\n      return 0;\n    },\n    finalize: function finalize(parser, block) {\n      var item = block._firstChild;\n\n      while (item) {\n        // check for non-final list item ending with blank line:\n        if (endsWithBlankLine(item) && item._next) {\n          block._listData.tight = false;\n          break;\n        } // recurse into children of list item, to see if there are\n        // spaces between any of them:\n\n\n        var subitem = item._firstChild;\n\n        while (subitem) {\n          if (endsWithBlankLine(subitem) && (item._next || subitem._next)) {\n            block._listData.tight = false;\n            break;\n          }\n\n          subitem = subitem._next;\n        }\n\n        item = item._next;\n      }\n    },\n    canContain: function canContain(t) {\n      return t === 'item';\n    },\n    acceptsLines: false\n  },\n  block_quote: {\n    continue: function _continue(parser) {\n      var ln = parser.currentLine;\n\n      if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(1, false);\n\n        if (isSpaceOrTab(peek(ln, parser.offset))) {\n          parser.advanceOffset(1, true);\n        }\n      } else {\n        return 1;\n      }\n\n      return 0;\n    },\n    finalize: function finalize() {\n      return;\n    },\n    canContain: function canContain(t) {\n      return t !== 'item';\n    },\n    acceptsLines: false\n  },\n  item: {\n    continue: function _continue(parser, container) {\n      if (parser.blank) {\n        if (container._firstChild == null) {\n          // Blank line after empty list item\n          return 1;\n        } else {\n          parser.advanceNextNonspace();\n        }\n      } else if (parser.indent >= container._listData.markerOffset + container._listData.padding) {\n        parser.advanceOffset(container._listData.markerOffset + container._listData.padding, true);\n      } else {\n        return 1;\n      }\n\n      return 0;\n    },\n    finalize: function finalize() {\n      return;\n    },\n    canContain: function canContain(t) {\n      return t !== 'item';\n    },\n    acceptsLines: false\n  },\n  heading: {\n    continue: function _continue() {\n      // a heading can never container > 1 line, so fail to match:\n      return 1;\n    },\n    finalize: function finalize() {\n      return;\n    },\n    canContain: function canContain() {\n      return false;\n    },\n    acceptsLines: false\n  },\n  thematic_break: {\n    continue: function _continue() {\n      // a thematic break can never container > 1 line, so fail to match:\n      return 1;\n    },\n    finalize: function finalize() {\n      return;\n    },\n    canContain: function canContain() {\n      return false;\n    },\n    acceptsLines: false\n  },\n  code_block: {\n    continue: function _continue(parser, container) {\n      var ln = parser.currentLine;\n      var indent = parser.indent;\n\n      if (container._isFenced) {\n        // fenced\n        var match = indent <= 3 && ln.charAt(parser.nextNonspace) === container._fenceChar && ln.slice(parser.nextNonspace).match(reClosingCodeFence);\n\n        if (match && match[0].length >= container._fenceLength) {\n          // closing fence - we're at end of line, so we can return\n          parser.finalize(container, parser.lineNumber);\n          return 2;\n        } else {\n          // skip optional spaces of fence offset\n          var i = container._fenceOffset;\n\n          while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {\n            parser.advanceOffset(1, true);\n            i--;\n          }\n        }\n      } else {\n        // indented\n        if (indent >= CODE_INDENT) {\n          parser.advanceOffset(CODE_INDENT, true);\n        } else if (parser.blank) {\n          parser.advanceNextNonspace();\n        } else {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n    finalize: function finalize(parser, block) {\n      if (block._isFenced) {\n        // fenced\n        // first line becomes info string\n        var content = block._string_content;\n        var newlinePos = content.indexOf('\\n');\n        var firstLine = content.slice(0, newlinePos);\n        var rest = content.slice(newlinePos + 1);\n        block.info = unescapeString(firstLine.trim());\n        block._literal = rest;\n      } else {\n        // indented\n        block._literal = block._string_content.replace(/(\\n *)+$/, '\\n');\n      }\n\n      block._string_content = null; // allow GC\n    },\n    canContain: function canContain() {\n      return false;\n    },\n    acceptsLines: true\n  },\n  html_block: {\n    continue: function _continue(parser, container) {\n      return parser.blank && (container._htmlBlockType === 6 || container._htmlBlockType === 7) ? 1 : 0;\n    },\n    finalize: function finalize(parser, block) {\n      block._literal = block._string_content.replace(/(\\n *)+$/, '');\n      block._string_content = null; // allow GC\n    },\n    canContain: function canContain() {\n      return false;\n    },\n    acceptsLines: true\n  },\n  paragraph: {\n    continue: function _continue(parser) {\n      return parser.blank ? 1 : 0;\n    },\n    finalize: function finalize(parser, block) {\n      var pos;\n      var hasReferenceDefs = false; // try parsing the beginning as link reference definitions:\n\n      while (peek(block._string_content, 0) === C_OPEN_BRACKET && (pos = parser.inlineParser.parseReference(block._string_content, parser.refmap))) {\n        block._string_content = block._string_content.slice(pos);\n        hasReferenceDefs = true;\n      }\n\n      if (hasReferenceDefs && isBlank(block._string_content)) {\n        block.unlink();\n      }\n    },\n    canContain: function canContain() {\n      return false;\n    },\n    acceptsLines: true\n  }\n}; // block start functions.  Return values:\n// 0 = no match\n// 1 = matched container, keep going\n// 2 = matched leaf, no more block starts\n\nvar blockStarts = [// block quote\nfunction (parser) {\n  if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n    parser.advanceNextNonspace();\n    parser.advanceOffset(1, false); // optional following space\n\n    if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n      parser.advanceOffset(1, true);\n    }\n\n    parser.closeUnmatchedBlocks();\n    parser.addChild('block_quote', parser.nextNonspace);\n    return 1;\n  } else {\n    return 0;\n  }\n}, // ATX heading\nfunction (parser) {\n  var match;\n\n  if (!parser.indented && (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {\n    parser.advanceNextNonspace();\n    parser.advanceOffset(match[0].length, false);\n    parser.closeUnmatchedBlocks();\n    var container = parser.addChild('heading', parser.nextNonspace);\n    container.level = match[0].trim().length; // number of #s\n    // remove trailing ###s:\n\n    container._string_content = parser.currentLine.slice(parser.offset).replace(/^[ \\t]*#+[ \\t]*$/, '').replace(/[ \\t]+#+[ \\t]*$/, '');\n    parser.advanceOffset(parser.currentLine.length - parser.offset);\n    return 2;\n  } else {\n    return 0;\n  }\n}, // Fenced code block\nfunction (parser) {\n  var match;\n\n  if (!parser.indented && (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n    var fenceLength = match[0].length;\n    parser.closeUnmatchedBlocks();\n    var container = parser.addChild('code_block', parser.nextNonspace);\n    container._isFenced = true;\n    container._fenceLength = fenceLength;\n    container._fenceChar = match[0][0];\n    container._fenceOffset = parser.indent;\n    parser.advanceNextNonspace();\n    parser.advanceOffset(fenceLength, false);\n    return 2;\n  } else {\n    return 0;\n  }\n}, // HTML block\nfunction (parser, container) {\n  if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {\n    var s = parser.currentLine.slice(parser.nextNonspace);\n    var blockType;\n\n    for (blockType = 1; blockType <= 7; blockType++) {\n      if (reHtmlBlockOpen[blockType].test(s) && (blockType < 7 || container.type !== 'paragraph')) {\n        parser.closeUnmatchedBlocks(); // We don't adjust parser.offset;\n        // spaces are part of the HTML block:\n\n        var b = parser.addChild('html_block', parser.offset);\n        b._htmlBlockType = blockType;\n        return 2;\n      }\n    }\n  }\n\n  return 0;\n}, // Setext heading\nfunction (parser, container) {\n  var match;\n\n  if (!parser.indented && container.type === 'paragraph' && (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {\n    parser.closeUnmatchedBlocks();\n    var heading = new Node('heading', container.sourcepos);\n    heading.level = match[0][0] === '=' ? 1 : 2;\n    heading._string_content = container._string_content;\n    container.insertAfter(heading);\n    container.unlink();\n    parser.tip = heading;\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    return 2;\n  } else {\n    return 0;\n  }\n}, // thematic break\nfunction (parser) {\n  if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {\n    parser.closeUnmatchedBlocks();\n    parser.addChild('thematic_break', parser.nextNonspace);\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    return 2;\n  } else {\n    return 0;\n  }\n}, // list item\nfunction (parser, container) {\n  var data;\n\n  if ((!parser.indented || container.type === 'list') && (data = parseListMarker(parser, container))) {\n    parser.closeUnmatchedBlocks(); // add the list if needed\n\n    if (parser.tip.type !== 'list' || !listsMatch(container._listData, data)) {\n      container = parser.addChild('list', parser.nextNonspace);\n      container._listData = data;\n    } // add the list item\n\n\n    container = parser.addChild('item', parser.nextNonspace);\n    container._listData = data;\n    return 1;\n  } else {\n    return 0;\n  }\n}, // indented code block\nfunction (parser) {\n  if (parser.indented && parser.tip.type !== 'paragraph' && !parser.blank) {\n    // indented code\n    parser.advanceOffset(CODE_INDENT, true);\n    parser.closeUnmatchedBlocks();\n    parser.addChild('code_block', parser.offset);\n    return 2;\n  } else {\n    return 0;\n  }\n}];\n\nvar advanceOffset = function advanceOffset(count, columns) {\n  var currentLine = this.currentLine;\n  var charsToTab, charsToAdvance;\n  var c;\n\n  while (count > 0 && (c = currentLine[this.offset])) {\n    if (c === '\\t') {\n      charsToTab = 4 - this.column % 4;\n\n      if (columns) {\n        this.partiallyConsumedTab = charsToTab > count;\n        charsToAdvance = charsToTab > count ? count : charsToTab;\n        this.column += charsToAdvance;\n        this.offset += this.partiallyConsumedTab ? 0 : 1;\n        count -= charsToAdvance;\n      } else {\n        this.partiallyConsumedTab = false;\n        this.column += charsToTab;\n        this.offset += 1;\n        count -= 1;\n      }\n    } else {\n      this.partiallyConsumedTab = false;\n      this.offset += 1;\n      this.column += 1; // assume ascii; block starts are ascii\n\n      count -= 1;\n    }\n  }\n};\n\nvar advanceNextNonspace = function advanceNextNonspace() {\n  this.offset = this.nextNonspace;\n  this.column = this.nextNonspaceColumn;\n  this.partiallyConsumedTab = false;\n};\n\nvar findNextNonspace = function findNextNonspace() {\n  var currentLine = this.currentLine;\n  var i = this.offset;\n  var cols = this.column;\n  var c;\n\n  while ((c = currentLine.charAt(i)) !== '') {\n    if (c === ' ') {\n      i++;\n      cols++;\n    } else if (c === '\\t') {\n      i++;\n      cols += 4 - cols % 4;\n    } else {\n      break;\n    }\n  }\n\n  this.blank = c === '\\n' || c === '\\r' || c === '';\n  this.nextNonspace = i;\n  this.nextNonspaceColumn = cols;\n  this.indent = this.nextNonspaceColumn - this.column;\n  this.indented = this.indent >= CODE_INDENT;\n}; // Analyze a line of text and update the document appropriately.\n// We parse markdown text by calling this on each line of input,\n// then finalizing the document.\n\n\nvar incorporateLine = function incorporateLine(ln) {\n  var all_matched = true;\n  var t;\n  var container = this.doc;\n  this.oldtip = this.tip;\n  this.offset = 0;\n  this.column = 0;\n  this.blank = false;\n  this.partiallyConsumedTab = false;\n  this.lineNumber += 1; // replace NUL characters for security\n\n  if (ln.indexOf(\"\\0\") !== -1) {\n    ln = ln.replace(/\\0/g, \"\\uFFFD\");\n  }\n\n  this.currentLine = ln; // For each containing block, try to parse the associated line start.\n  // Bail out on failure: container will point to the last matching block.\n  // Set all_matched to false if not all containers match.\n\n  var lastChild;\n\n  while ((lastChild = container._lastChild) && lastChild._open) {\n    container = lastChild;\n    this.findNextNonspace();\n\n    switch (this.blocks[container.type].continue(this, container)) {\n      case 0:\n        // we've matched, keep going\n        break;\n\n      case 1:\n        // we've failed to match a block\n        all_matched = false;\n        break;\n\n      case 2:\n        // we've hit end of line for fenced code close and can return\n        this.lastLineLength = ln.length;\n        return;\n\n      default:\n        throw 'continue returned illegal value, must be 0, 1, or 2';\n    }\n\n    if (!all_matched) {\n      container = container._parent; // back up to last matching block\n\n      break;\n    }\n  }\n\n  this.allClosed = container === this.oldtip;\n  this.lastMatchedContainer = container;\n  var matchedLeaf = container.type !== 'paragraph' && blocks[container.type].acceptsLines;\n  var starts = this.blockStarts;\n  var startsLen = starts.length; // Unless last matched container is a code block, try new container starts,\n  // adding children to the last matched container:\n\n  while (!matchedLeaf) {\n    this.findNextNonspace(); // this is a little performance optimization:\n\n    if (!this.indented && !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n      this.advanceNextNonspace();\n      break;\n    }\n\n    var i = 0;\n\n    while (i < startsLen) {\n      var res = starts[i](this, container);\n\n      if (res === 1) {\n        container = this.tip;\n        break;\n      } else if (res === 2) {\n        container = this.tip;\n        matchedLeaf = true;\n        break;\n      } else {\n        i++;\n      }\n    }\n\n    if (i === startsLen) {\n      // nothing matched\n      this.advanceNextNonspace();\n      break;\n    }\n  } // What remains at the offset is a text line.  Add the text to the\n  // appropriate container.\n  // First check for a lazy paragraph continuation:\n\n\n  if (!this.allClosed && !this.blank && this.tip.type === 'paragraph') {\n    // lazy paragraph continuation\n    this.addLine();\n  } else {\n    // not a lazy continuation\n    // finalize any blocks not matched\n    this.closeUnmatchedBlocks();\n\n    if (this.blank && container.lastChild) {\n      container.lastChild._lastLineBlank = true;\n    }\n\n    t = container.type; // Block quote lines are never blank as they start with >\n    // and we don't count blanks in fenced code for purposes of tight/loose\n    // lists or breaking out of lists.  We also don't set _lastLineBlank\n    // on an empty list item, or if we just closed a fenced block.\n\n    var lastLineBlank = this.blank && !(t === 'block_quote' || t === 'code_block' && container._isFenced || t === 'item' && !container._firstChild && container.sourcepos[0][0] === this.lineNumber); // propagate lastLineBlank up through parents:\n\n    var cont = container;\n\n    while (cont) {\n      cont._lastLineBlank = lastLineBlank;\n      cont = cont._parent;\n    }\n\n    if (this.blocks[t].acceptsLines) {\n      this.addLine(); // if HtmlBlock, check for end condition\n\n      if (t === 'html_block' && container._htmlBlockType >= 1 && container._htmlBlockType <= 5 && reHtmlBlockClose[container._htmlBlockType].test(this.currentLine.slice(this.offset))) {\n        this.finalize(container, this.lineNumber);\n      }\n    } else if (this.offset < ln.length && !this.blank) {\n      // create paragraph container for line\n      container = this.addChild('paragraph', this.offset);\n      this.advanceNextNonspace();\n      this.addLine();\n    }\n  }\n\n  this.lastLineLength = ln.length;\n}; // Finalize a block.  Close it and do any necessary postprocessing,\n// e.g. creating string_content from strings, setting the 'tight'\n// or 'loose' status of a list, and parsing the beginnings\n// of paragraphs for reference definitions.  Reset the tip to the\n// parent of the closed block.\n\n\nvar finalize = function finalize(block, lineNumber) {\n  var above = block._parent;\n  block._open = false;\n  block.sourcepos[1] = [lineNumber, this.lastLineLength];\n  this.blocks[block.type].finalize(this, block);\n  this.tip = above;\n}; // Walk through a block & children recursively, parsing string content\n// into inline content where appropriate.\n\n\nvar processInlines = function processInlines(block) {\n  var node, event, t;\n  var walker = block.walker();\n  this.inlineParser.refmap = this.refmap;\n  this.inlineParser.options = this.options;\n\n  while (event = walker.next()) {\n    node = event.node;\n    t = node.type;\n\n    if (!event.entering && (t === 'paragraph' || t === 'heading')) {\n      this.inlineParser.parse(node);\n    }\n  }\n};\n\nvar Document = function Document() {\n  var doc = new Node('document', [[1, 1], [0, 0]]);\n  return doc;\n}; // The main parsing function.  Returns a parsed document AST.\n\n\nvar parse = function parse(input) {\n  this.doc = new Document();\n  this.tip = this.doc;\n  this.refmap = {};\n  this.lineNumber = 0;\n  this.lastLineLength = 0;\n  this.offset = 0;\n  this.column = 0;\n  this.lastMatchedContainer = this.doc;\n  this.currentLine = \"\";\n\n  if (this.options.time) {\n    console.time(\"preparing input\");\n  }\n\n  var lines = input.split(reLineEnding);\n  var len = lines.length;\n\n  if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n    // ignore last blank line created by final newline\n    len -= 1;\n  }\n\n  if (this.options.time) {\n    console.timeEnd(\"preparing input\");\n  }\n\n  if (this.options.time) {\n    console.time(\"block parsing\");\n  }\n\n  for (var i = 0; i < len; i++) {\n    this.incorporateLine(lines[i]);\n  }\n\n  while (this.tip) {\n    this.finalize(this.tip, len);\n  }\n\n  if (this.options.time) {\n    console.timeEnd(\"block parsing\");\n  }\n\n  if (this.options.time) {\n    console.time(\"inline parsing\");\n  }\n\n  this.processInlines(this.doc);\n\n  if (this.options.time) {\n    console.timeEnd(\"inline parsing\");\n  }\n\n  return this.doc;\n}; // The Parser object.\n\n\nfunction Parser(options) {\n  return {\n    doc: new Document(),\n    blocks: blocks,\n    blockStarts: blockStarts,\n    tip: this.doc,\n    oldtip: this.doc,\n    currentLine: \"\",\n    lineNumber: 0,\n    offset: 0,\n    column: 0,\n    nextNonspace: 0,\n    nextNonspaceColumn: 0,\n    indent: 0,\n    indented: false,\n    blank: false,\n    partiallyConsumedTab: false,\n    allClosed: true,\n    lastMatchedContainer: this.doc,\n    refmap: {},\n    lastLineLength: 0,\n    inlineParser: new InlineParser(options),\n    findNextNonspace: findNextNonspace,\n    advanceOffset: advanceOffset,\n    advanceNextNonspace: advanceNextNonspace,\n    addLine: addLine,\n    addChild: addChild,\n    incorporateLine: incorporateLine,\n    finalize: finalize,\n    processInlines: processInlines,\n    closeUnmatchedBlocks: closeUnmatchedBlocks,\n    parse: parse,\n    options: options || {}\n  };\n}\n\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}